@page "/"
@using Blazor.Extensions;
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D;
@using BreakOutGame.BreakoutGameObjects;
@inject IJSRuntime JSRuntime;

<BECanvas Width="_gameWidth" Height="_gameHeight" @ref="_canvasReference"></BECanvas>

@code {
    private Canvas2DContext _context;

    private const int _gameHeight = 600;
    private const int _gameWidth = 800;

    protected BECanvasComponent _canvasReference;

    private Ball _ball;
    private Paddle _paddle;

    private Task engine;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        this._context = await this._canvasReference.CreateCanvas2DAsync();

        await InitalizeGameObjects();
        if (firstRender)
        {
            engine = GameLoop();
        }
    }

    public async Task GameLoop()
    {
        var i = 0;
        while (i < 1000000)
        {
            await Task.Delay(1);
            await _context.ClearRectAsync(0, 0, _gameWidth, _gameHeight);

            UpdateGameObjects();
            await DrawGameObject();
            i++;
        }
    }

    private void UpdateGameObjects()
    {
        this._ball.Update();
        //this._paddle.Update();
    }

    private async Task DrawGameObject()
    {
        await this._ball.Draw(_context);
        await this._paddle.Draw(_context);
    }

    private async Task InitalizeGameObjects()
    {
        this._paddle = new Paddle(_gameWidth, _gameHeight);
        await this._paddle.Draw(_context);

        this._ball = new Ball(_gameWidth, _gameHeight, this._paddle);
        await this._ball.Draw(_context);
    }
}